from abc import abstractproperty

from ..hdl import *
from ..build import *


__all__ = ["AlteraPlatform"]


class AlteraPlatform(TemplatedPlatform):
    """
    Required tools:
        * ``quartus_map``
        * ``quartus_fit``
        * ``quartus_asm``
        * ``quartus_sta``

    The environment is populated by running the script specified in the environment variable
    ``NMIGEN_Quartus_env``, if present.

    Available overrides:
        * ``nproc``: sets the number of cores used by all tools.
        * ``quartus_map_opts``: adds extra options for ``quartus_map``.
        * ``quartus_fit_opts``: adds extra options for ``quartus_fit``.
        * ``quartus_asm_opts``: adds extra options for ``quartus_asm``.
        * ``quartus_sta_opts``: adds extra options for ``quartus_sta``.

    Build products:
        * ``*.rpt``: toolchain reports.
        * ``{{name}}.rbf``: raw binary bitstream.
    """

    toolchain = "Quartus"

    device  = abstractproperty()
    package = abstractproperty()
    speed   = abstractproperty()
    suffix  = ""

    required_tools = [
        "quartus_map",
        "quartus_fit",
        "quartus_asm",
        "quartus_sta",
    ]

    file_templates = {
        **TemplatedPlatform.build_script_templates,
        "build_{{name}}.sh": r"""
            # {{autogenerated}}
            if [ -n "$NMIGEN_{{platform.toolchain}}_env" ]; then
                QUARTUS_ROOTDIR=$(dirname $(dirname "$NMIGEN_{{platform.toolchain}}_env"))
                # Quartus' qenv.sh does not work with `set -e`.
                . "$NMIGEN_{{platform.toolchain}}_env"
            fi
            set -e{{verbose("x")}}
            {{emit_commands("sh")}}
        """,
        "{{name}}.v": r"""
            /* {{autogenerated}} */
            {{emit_verilog()}}
        """,
        "{{name}}.debug.v": r"""
            /* {{autogenerated}} */
            {{emit_debug_verilog()}}
        """,
        "{{name}}.qsf": r"""
            # {{autogenerated}}
            {% if get_override("nproc") -%}
                set_global_assignment -name NUM_PARALLEL_PROCESSORS {{get_override("nproc")}}
            {% endif %}

            {% for file in platform.iter_extra_files(".v") -%}
                set_global_assignment -name VERILOG_FILE "{{file}}"
            {% endfor %}
            {% for file in platform.iter_extra_files(".sv") -%}
                set_global_assignment -name SYSTEMVERILOG_FILE "{{file}}"
            {% endfor %}
            set_global_assignment -name VERILOG_FILE {{name}}.v
            set_global_assignment -name TOP_LEVEL_ENTITY {{name}}

            set_global_assignment -name DEVICE {{platform.device}}{{platform.package}}{{platform.speed}}{{platform.suffix}}
            {% for port_name, pin_name, extras in platform.iter_port_constraints_bits() -%}
                set_location_assignment -to "{{port_name}}" PIN_{{pin_name}}
                {% for key, value in extras.items() -%}
                    set_instance_assignment -to "{{port_name}}" -name {{key}} "{{value}}"
                {% endfor %}
            {% endfor %}

            set_global_assignment -name GENERATE_RBF_FILE ON
        """,
        "{{name}}.sdc": r"""
            {% for signal, frequency in platform.iter_clock_constraints() -%}
                create_clock -period {{1000000000/frequency}} [get_nets {{signal|hierarchy("/")}}]
            {% endfor %}
        """,
    }
    command_templates = [
        r"""
        {{get_tool("quartus_map")}}
            {{get_override("quartus_map_opts")|options}}
            --rev={{name}} {{name}}
        """,
        r"""
        {{get_tool("quartus_fit")}}
            {{get_override("quartus_fit_opts")|options}}
            --rev={{name}} {{name}}
        """,
        r"""
        {{get_tool("quartus_asm")}}
            {{get_override("quartus_asm_opts")|options}}
            --rev={{name}} {{name}}
        """,
        r"""
        {{get_tool("quartus_sta")}}
            {{get_override("quartus_sta_opts")|options}}
            --rev={{name}} {{name}}
        """,
    ]

    def create_missing_domain(self, name):
        # TODO: investigate this
        return super().create_missing_domain(name)

    # TODO: fix all of the following
    @staticmethod
    def _invert_if(invert, value):
        if invert:
            return ~value
        else:
            return value

    def get_input(self, pin, port, attrs, invert):
        self._check_feature("single-ended input", pin, attrs,
                            valid_xdrs=(0,1), valid_attrs=True)

        m = Module()

        ff_i = Signal(pin.width)

        if pin.xdr == 1:
            pin.i.attrs["useioff"] = "1"

        for bit in range(pin.width):
            m.submodules["{}_buf_{}".format(pin.name, bit)] = Instance("alt_inbuf",
                i_i=port[bit],
                o_o=ff_i[bit]
            )
            
            if pin.xdr == 0:
                m.d.comb += pin.i[bit].eq(self._invert_if(invert, ff_i[bit]))
            elif pin.xdr == 1:
                m.submodules["{}_dff_i_{}".format(pin.name, bit)] += Instance("dff",
                    i_d=self._invert_if(invert, ff_i[bit]),
                    i_clk=pin.i_clk,
                    i_clrn=1,
                    i_prn=1,
                    o_q=pin.i[bit]
                )

        return m

    def get_output(self, pin, port, attrs, invert):
        self._check_feature("single-ended output", pin, attrs,
                            valid_xdrs=(0,1), valid_attrs=True)

        m = Module()

        ff_o = Signal(pin.width)

        if pin.xdr == 1:
            pin.o.attrs["useioff"] = "1"

        for bit in range(pin.width):
            if pin.xdr == 0:
                m.d.comb += ff_o[bit].eq(self._invert_if(invert, pin.o[bit]))
            elif pin.xdr == 1:
                m.submodules["{}_dff_o_{}".format(pin.name, bit)] += Instance("dff",
                    i_d=self._invert_if(invert, pin.o[bit]),
                    i_clk=pin.i_clk,
                    i_clrn=1,
                    i_prn=1,
                    o_q=ff_o[bit]
                )

            m.submodules["{}_buf_{}".format(pin.name, bit)] = Instance("alt_outbuf",
                i_i=ff_o[bit],
                o_o=port[bit]
            )
            
        return m

    def get_tristate(self, pin, port, attrs, invert):
        self._check_feature("single-ended tristate", pin, attrs,
                            valid_xdrs=(0,1), valid_attrs=True)

        m = Module()

        ff_o = Signal(pin.width)
        ff_oe = Signal(pin.width)

        if pin.xdr == 1:
            pin.o.attrs["useioff"] = "1"
            pin.oe.attrs["useioff"] = "1"

        for bit in range(pin.width):
            if pin.xdr == 0:
                m.d.comb += ff_o[bit].eq(self._invert_if(invert, pin.o[bit]))
                m.d.comb += ff_oe[bit].eq(pin.oe[bit])
            elif pin.xdr == 1:
                m.submodules["{}_dff_o__{}".format(pin.name, bit)] += Instance("dff",
                    i_d=self._invert_if(invert, pin.o[bit]),
                    i_clk=pin.i_clk,
                    i_clrn=1,
                    i_prn=1,
                    o_q=ff_o[bit]
                )
                m.submodules["{}_dff_oe_{}".format(pin.name, bit)] += Instance("dff",
                    i_d=pin.oe[bit],
                    i_clk=pin.i_clk,
                    i_clrn=1,
                    i_prn=1,
                    o_q=ff_oe[bit]
                )

            m.submodules["{}_buf_{}".format(pin.name, bit)] = Instance("alt_outbuf_tri",
                i_i=ff_o[bit],
                i_oe=ff_oe[bit],
                o_o=port[bit]
            )

        return m

    def get_input_output(self, pin, port, attrs, invert):
        self._check_feature("single-ended input/output", pin, attrs,
                            valid_xdrs=(0,1), valid_attrs=True)

        m = Module()

        ff_i = Signal(pin.width)
        ff_o = Signal(pin.width)
        ff_oe = Signal(pin.width)

        if pin.xdr == 1:
            pin.i.attrs["useioff"] = "1"
            pin.o.attrs["useioff"] = "1"
            pin.oe.attrs["useioff"] = "1"

        for bit in range(pin.width):
            if pin.xdr == 0:
                m.d.comb += pin.i[bit].eq(self._invert_if(invert, ff_i[bit]))
                m.d.comb += ff_o[bit].eq(self._invert_if(invert, pin.o[bit]))
                m.d.comb += ff_oe[bit].eq(pin.oe[bit])
            elif pin.xdr == 1:
                m.submodules["{}_dff_i_{}".format(pin.name, bit)] += Instance("dff",
                    i_d=self._invert_if(invert, ff_i[bit]),
                    i_clk=pin.i_clk,
                    i_clrn=1,
                    i_prn=1,
                    o_q=pin.i[bit]
                )
                m.submodules["{}_dff_o__{}".format(pin.name, bit)] += Instance("dff",
                    i_d=self._invert_if(invert, pin.o[bit]),
                    i_clk=pin.i_clk,
                    i_clrn=1,
                    i_prn=1,
                    o_q=ff_o[bit]
                )
                m.submodules["{}_dff_oe_{}".format(pin.name, bit)] += Instance("dff",
                    i_d=pin.oe[bit],
                    i_clk=pin.i_clk,
                    i_clrn=1,
                    i_prn=1,
                    o_q=ff_oe[bit]
                )

            m.submodules["{}_buf_{}".format(pin.name, bit)] = Instance("alt_iobuf",
                i_i=ff_o[bit],
                i_oe=ff_oe[bit],
                o_o=ff_i[bit],
                io_io=port[bit]
            )

        return m

    def get_diff_input(self, pin, p_port, n_port, attrs, invert):
        self._check_feature("differential input", pin, attrs,
                            valid_xdrs=(0,1), valid_attrs=True)
        m = Module()

        ff_i = Signal(pin.width)

        if pin.xdr == 1:
            pin.i.attrs["useioff"] = "1"

        for bit in range(pin.width):
            m.submodules["{}_buf_{}".format(pin.name, bit)] = Instance("alt_inbuf_diff",
                i_i=p_port[bit],
                i_ibar=n_port[bit],
                o_o=ff_i[bit]
            )
            
            if pin.xdr == 0:
                m.d.comb += pin.i[bit].eq(self._invert_if(invert, ff_i[bit]))
            elif pin.xdr == 1:
                m.submodules["{}_dff_i_{}".format(pin.name, bit)] += Instance("dff",
                    i_d=self._invert_if(invert, ff_i[bit]),
                    i_clk=pin.i_clk,
                    i_clrn=1,
                    i_prn=1,
                    o_q=pin.i[bit]
                )
 
        return m

    def get_diff_output(self, pin, p_port, n_port, attrs, invert):
        self._check_feature("differential output", pin, attrs,
                            valid_xdrs=(0,1), valid_attrs=True)
        m = Module()

        ff_o = Signal(pin.width)

        if pin.xdr == 1:
            pin.o.attrs["useioff"] = "1"

        for bit in range(pin.width):
            if pin.xdr == 0:
                m.d.comb += ff_o[bit].eq(self._invert_if(invert, pin.o[bit]))
            elif pin.xdr == 1:
                m.submodules["{}_dff_o_{}".format(pin.name, bit)] += Instance("dff",
                    i_d=self._invert_if(invert, pin.o[bit]),
                    i_clk=pin.i_clk,
                    i_clrn=1,
                    i_prn=1,
                    o_q=ff_o[bit]
                )

            m.submodules["{}_buf_{}".format(pin.name, bit)] = Instance("alt_outbuf_diff",
                i_i=ff_o[bit],
                o_o=p_port[bit],
                o_obar=n_port[bit]
            )

        return m

    def get_diff_tristate(self, pin, p_port, n_port, attrs, invert):
        self._check_feature("differential tristate", pin, attrs,
                            valid_xdrs=(0,1), valid_attrs=True)
        m = Module()

        ff_o = Signal(pin.width)
        ff_oe = Signal(pin.width)

        if pin.xdr == 1:
            pin.o.attrs["useioff"] = "1"
            pin.oe.attrs["useioff"] = "1"

        for bit in range(pin.width):
            if pin.xdr == 0:
                m.d.comb += ff_o[bit].eq(self._invert_if(invert, pin.o[bit]))
                m.d.comb += ff_oe[bit].eq(pin.oe[bit])
            elif pin.xdr == 1:
                m.submodules["{}_dff_o__{}".format(pin.name, bit)] += Instance("dff",
                    i_d=self._invert_if(invert, pin.o[bit]),
                    i_clk=pin.i_clk,
                    i_clrn=1,
                    i_prn=1,
                    o_q=ff_o[bit]
                )
                m.submodules["{}_dff_oe_{}".format(pin.name, bit)] += Instance("dff",
                    i_d=pin.oe[bit],
                    i_clk=pin.i_clk,
                    i_clrn=1,
                    i_prn=1,
                    o_q=ff_oe[bit]
                )

            m.submodules["{}_buf_{}".format(pin.name, bit)] = Instance("alt_outbuf_tri_diff",
                i_i=ff_o[bit],
                i_oe=ff_oe[bit],
                o_o=p_port[bit],
                o_obar=n_port[bit]
            )

        return m

    def get_diff_input_output(self, pin, p_port, n_port, attrs, invert):
        self._check_feature("differential input/output", pin, attrs,
                            valid_xdrs=(0,1), valid_attrs=True)
        m = Module()

        ff_i = Signal(pin.width)
        ff_o = Signal(pin.width)
        ff_oe = Signal(pin.width)

        if pin.xdr == 1:
            pin.i.attrs["useioff"] = "1"
            pin.o.attrs["useioff"] = "1"
            pin.oe.attrs["useioff"] = "1"

        for bit in range(pin.width):
            if pin.xdr == 0:
                m.d.comb += pin.i[bit].eq(self._invert_if(invert, ff_i[bit]))
                m.d.comb += ff_o[bit].eq(self._invert_if(invert, pin.o[bit]))
                m.d.comb += ff_oe[bit].eq(pin.oe[bit])
            elif pin.xdr == 1:
                m.submodules["{}_dff_i_{}".format(pin.name, bit)] += Instance("dff",
                    i_d=self._invert_if(invert, ff_i[bit]),
                    i_clk=pin.i_clk,
                    i_clrn=1,
                    i_prn=1,
                    o_q=pin.i[bit]
                )
                m.submodules["{}_dff_o__{}".format(pin.name, bit)] += Instance("dff",
                    i_d=self._invert_if(invert, pin.o[bit]),
                    i_clk=pin.i_clk,
                    i_clrn=1,
                    i_prn=1,
                    o_q=ff_o[bit]
                )
                m.submodules["{}_dff_oe_{}".format(pin.name, bit)] += Instance("dff",
                    i_d=pin.oe[bit],
                    i_clk=pin.i_clk,
                    i_clrn=1,
                    i_prn=1,
                    o_q=ff_oe[bit]
                )

            m.submodules["{}_buf_{}".format(pin.name, bit)] = Instance("alt_iobuf_diff",
                i_i=ff_o[bit],
                i_oe=ff_oe[bit],
                o_o=ff_i[bit],
                io_io=p_port[bit],
                io_iobar=n_port[bit]
            )

        return m
